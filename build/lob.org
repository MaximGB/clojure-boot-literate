Тут описаны вспомогательные функции-блоки для литературного проекта. Эти функции-блоки работают в среде *Emacs/Org*,
они не предназначены для вызова из Clojure.

* time-is-now

  Возвращает текущее время в виде строки в заданном формате.

  *Примеры:*
  #+BEGIN_EXAMPLE
    <<time-is-now()>>
    <<time-is-now(format="%F")
    #+CALL: time-is-now()
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя    | Значение по умолчанию | Описание                    |
  |--------+-----------------------+-----------------------------|
  | format | "%F %X"               | Формат возвращаемой строки. |

  #+NAME: time-is-now
  #+BEGIN_SRC emacs-lisp :var format="%F %X" :results value silent
    (format-time-string format)
  #+END_SRC

* get-table-param
  :PROPERTIES:
  :CUSTOM_ID: lob-get-table-param
  :END:

  Возвращает значение параметра с указанным именем из какой-либо таблицы. В первой колонке таблицы задаются имена
  параметров, во второй колонке - значения.

  *Примеры:*
  #+BEGIN_EXAMPLE
    <<get-table-param(table=../project.org:project-specification, title="Имя проекта")>>
    <<get-table-param(table=../project.org:project-specification, title="Имя проекта", splitby="-", joinby="_")>>
    <<get-table param(table=../project.org:project-specification, title="Clojure/Версия")>>
    #+CALL: get-table-param(table=../project.org:project-specification, title="Имя проекта")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя     | Значение по умолчанию | Описание                                                                         |
  |---------+-----------------------+----------------------------------------------------------------------------------|
  | table   | (quote ())            | Ссылка на таблицу. В виде [путь к файлу с таблицей:]имя таблицы, например:       |
  |         |                       | ../file.org:table_name или просто table_name если таблица находится в том же |
  |         |                       | файле из которого делается вызов. Значение по-умолчанию позволяет просто без     |
  |         |                       | ошибки вернуть nil, так как таблица передаётся в блок просто в виде списка.      |
  |---------+-----------------------+----------------------------------------------------------------------------------|
  | title   | ""                    | Имя параметра. Поддерживаются имена-пути, или емена содержащие '/'. Если         |
  |         |                       | задан такой параметр, то он разбивается на части, и каждая часть рассматривается |
  |         |                       | как отдельный параметр. Поиск очередного параметра начинается со строки          |
  |         |                       | предыдущего, значение предыдущего параметра отбрасывается. Возвращается значение |
  |         |                       | последнего параметра.                                                            |
  |---------+-----------------------+----------------------------------------------------------------------------------|
  | splitby | ""                    | Разделитель значений параметра. Работает совместно с joinby. Если значения       |
  |         |                       | в ячейке перечислены, например, через запятую, то, указав splitby=",", мы их     |
  |         |                       | разделим, и разделённые значения будут объеденены с помощью joinby.              |
  |---------+-----------------------+----------------------------------------------------------------------------------|
  | joinby  |                       | Объединитель значений параметра. Работает совместно со splitby.                  |

  #+NAME: get-table-param
  #+BEGIN_SRC emacs-lisp :var table=(quote ()) :var title="" :var splitby="" :var joinby="" :hlines yes :results value silent
    (let* ((table-adopted (mapcar (lambda (x)
                                    (if (equal x 'hline)
                                       '(hline hline hline)
                                     x))
                                  table))
           (titles (mapcar #'car table-adopted))
           (path (split-string title (regexp-quote "/")))
           (last-index (reduce (lambda (index title)
                                 (cl-position title titles :start index :test #'equal))
                               path
                               :initial-value nil)))
      (if last-index
          (let* ((result (nth 1 (nth last-index table-adopted))))
            (if (and result splitby joinby)
                (mapconcat #'identity (split-string result (regexp-quote splitby) t "\s+") joinby)
              result))))
  #+END_SRC

* get-specification-param

  Возвращает значение параметра с указанным именем из спецификации проекта.

  *Примеры:*
  #+BEGIN_EXAMPLE
    <<get-specification-param(title="Имя проекта")>>
    <<get-specification-param(title="Пространство имён main", splitby="." joinby="/")>>
    #+CALL: get-specification-param(title="Имя проекта")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя     | Значение по умолчанию | Описание                                                |
  |---------+-----------------------+---------------------------------------------------------|
  | title   | ""                    | Имя параметра (см. [[#lob-get-table-param][(get-table-param)]]).                  |
  | splitby | ""                    | Разделитель значений параметра (см. [[#lob-get-table-param][(get-table-param)]]). |
  | joinby  |                       | Объединитель значений параметр (см. [[#lob-get-table-param][(get-table-param)]]). |

  #+NAME: get-specification-param
  #+BEGIN_SRC emacs-lisp :var title="" :var splitby="" :var joinby="" :results value silent
    (save-excursion
      (let ((project-org-dir (locate-dominating-file (buffer-file-name) "project.org")))
           (if project-org-dir
             (let ((project-spec-ref (concat project-org-dir "project.org:project-specification")))
                  (org-babel-execute-src-block
                    nil
                    (cdr (assoc 'get-table-param org-babel-library-of-babel))
                    (list
                      (cons :var (format "table=%s" project-spec-ref))
                      (cons :var (format "title=\"%s\"" title))
                      (cons :var (format "splitby=\"%s\"" splitby))
                      (cons :var (format "joinby=\"%s\""  joinby))))))))
  #+END_SRC

* in-some-path

  Возвращает абсолютный путь до файла в одной из дирректорий экспортируемых исходников проекта с учётом имени проекта
  и промежуточной дирректории, задаваемой параметром из спецификации проекта.

  *Требования*: В спецификации проекта должен быть заданы параметры:
  - Имя проекта
  - Параметр передаваемый через param

  *Примеры:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-some-path (param="Clojure/Расположение исходников" path \"core.clj\"))
       ...
    #+END_SRC
    <<in-some-path(param="Clojure/Расоложение исходников", path="core.clj")>>
    #+CALL: in-some-path(param="Clojure/Расположение исходников", path="core.clj")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{8cm}| :float nil
  | Имя         | Значение по умолчанию             | Описание                                                      |
  |-------------+-----------------------------------+---------------------------------------------------------------|
  | param       | "Clojure/Расположение исходников" | Имя параметра, задющего часть пути относительно корня проекта |
  | path        | ""                                | Путь относительно дирректории исходников                      |
  | projectvise | t                                 | Вставлять имя проекта между базовой дирректорией              |
  |             |                                   | и формируемым окончанием пути.                                |

  #+NAME: in-some-path
  #+BEGIN_SRC emacs-lisp :var param="Clojure/Расположение исходников" :var path="" :var projectvise='t :results value silent
    (save-excursion
      (let* ((project-org-dir (locate-dominating-file (buffer-file-name) "project.org"))
             (src-path (org-babel-execute-src-block
                         nil
                         (cdr (assoc 'get-specification-param org-babel-library-of-babel))
                         (list
                           (cons :var (format "title=\"%s\"" param)))))
             (project-name (org-babel-execute-src-block
                             nil
                             (cdr (assoc 'get-specification-param org-babel-library-of-babel))
                             (list
                               (cons :var "title=\"Имя проекта\"")
                               (cons :var "splitby=\".\"")
                               (cons :var "joinby=\"/\""))))
             (ns-path (replace-regexp-in-string "\-" "_" project-name)))
            (concat project-org-dir src-path "/" (if projectvise (concat ns-path "/") "") path)))
  #+END_SRC

* in-clj-path

  Возвращает абсолютный путь до файла в дирректории экспортируемых clj-исходников проекта с учётом имени проекта.

  *Требования*: В спецификации проекта должен быть заданы параметры:
  - Имя проекта
  - Clojure/Расположение исходников

  *Примеры:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-clj-path (path \"core.clj\"))
       ...
    #+END_SRC
    <<in-clj-path(path="core.clj")>>
    #+CALL: in-clj-path(path="core.clj")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя  | Значение по умолчанию | Описание                                         |
  |------+-----------------------+--------------------------------------------------|
  | path | ""                    | Путь относительно дирректории Clojure исходников |

  #+NAME: in-clj-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Clojure/Расположение исходников\"")
         (cons :var (format "path=\"%s\"" path)))))
  #+END_SRC

* in-cljs-path

  Возвращает абсолютный путь до файла в дирректории экспортируемых cljs-исходников проекта с учётом имени проекта.

  *Требования*: В спецификации проекта должен быть заданы параметры:
  - Имя проекта
  - ClojureScript/Расположение исходников

  *Примеры:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-cljs-path (path \"core.clj\"))
       ...
    #+END_SRC
    <<in-cljs-path(path="core.clj")>>
    #+CALL: in-cljs-path(path="core.clj")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя  | Значение по умолчанию | Описание                                               |
  |------+-----------------------+--------------------------------------------------------|
  | path | ""                    | Путь относительно дирректории ClojureScript исходников |

  #+NAME: in-cljs-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"ClojureScript/Расположение исходников\"")
         (cons :var (format "path=\"%s\"" path)))))
  #+END_SRC

* in-tests-path

  Возвращает абсолютный путь до файла в дирректории экспортируемых тестов проекта с учётом имени проекта.

  *Требования*: В спецификации проекта должен быть заданы параметры:
  - Имя проекта
  - Расположение тестов

  *Примеры:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-tests-path (path \"core.clj\"))
       ...
    #+END_SRC
    <<in-tests-path(path="core.clj")>>
    #+CALL: in-tests-path(path="core.clj")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя  | Значение по умолчанию | Описание                                        |
  |------+-----------------------+-------------------------------------------------|
  | path | ""                    | Путь относительно дирректории исходников тестов |

  #+NAME: in-tests-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Расположение тестов\"")
         (cons :var (format "path=\"%s\"" path)))))
  #+END_SRC

* in-resources-path

  Возвращает абсолютный путь до файла в дирректории classpath ресурсов.

  *Требования*: В спецификации проекта должен быть заданы параметры:
  - Имя проекта
  - Расположение classpath ресурсов

  *Примеры:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-resources-path (path \"index.html"))
       ...
    #+END_SRC
    <<in-resources-path(path="index.html")>>
    #+CALL: in-resources-path(path="index.html")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя  | Значение по умолчанию | Описание                               |
  |------+-----------------------+----------------------------------------|
  | path | ""                    | Путь относительно дирректории ресурсов |

  #+NAME: in-resources-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Расположение classpath ресурсов\"")
         (cons :var (format "path=\"%s\"" path))
         (cons :var "projectvise=()"))))
  #+END_SRC

* in-assets-path

  Возвращает абсолютный путь до файла в дирректории прочих ресурсов.

  *Требования*: В спецификации проекта должен быть заданы параметры:
  - Имя проекта
  - Расположение прочих ресурсов

  *Примеры:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-resources-path (path \"index.html"))
       ...
    #+END_SRC
    <<in-resources-path(path="index.html")>>
    #+CALL: in-resources-path(path="index.html")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя  | Значение по умолчанию | Описание                               |
  |------+-----------------------+----------------------------------------|
  | path | ""                    | Путь относительно дирректории ресурсов |

  #+NAME: in-assets-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Расположение прочих ресурсов\"")
         (cons :var (format "path=\"%s\"" path))
         (cons :var "projectvise=()"))))
  #+END_SRC
* in-target-path

  Возвращает абсолютный путь до файла в целевой дирректории.

  *Требования*: В спецификации проекта должен быть заданы параметры:
  - Имя проекта
  - Целевая дирректория

  *Примеры:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-target-path (path \"index.html"))
       ...
    #+END_SRC
    <<in-target-path(path="index.html")>>
    #+CALL: in-target-path(path="index.html")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя  | Значение по умолчанию | Описание                              |
  |------+-----------------------+---------------------------------------|
  | path | ""                    | Путь относительно целевой дирректории |

  #+NAME: in-target-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Целевая дирректория\"")
         (cons :var (format "path=\"%s\"" path))
         (cons :var "projectvise=()"))))
  #+END_SRC

* render-project-dependencies

  Возвращает строки содержащие зависимости проекта взятые из таблицы зависимостей

  *Примеры:*
  #+BEGIN_EXAMPLE
    <<render-project-dependencies()>>
    #+CALL: render-project-dependencies()
  #+END_EXAMPLE

  #+NAME: render-project-dependencies
  #+BEGIN_SRC emacs-lisp :results value silent
    ; Full dependency definition specification is given here
    ; https://github.com/cemerick/pomegranate/blob/master/src/main/clojure/cemerick/pomegranate/aether.clj
    ; in resolve-dependencies function
    (let ((project-org-dir (locate-dominating-file (buffer-file-name) "project.org")))
      (if project-org-dir
          (let* ((project-spec-ref (concat project-org-dir "project.org:project-dependencies"))
                 ; deps-table is a list of lists and hlines
                 (deps-table (org-babel-ref-resolve project-spec-ref))
                 ; Dependency representing hash-map key traversing sequence
                 (serialize-key-traversing-seq '(name version scope optional classifier extension exclusions)))
            (cl-labels (
                      ; dependency hash map has following keys
                      ; - name - dependency artifact name
                      ; - version - dependency artifact version
                      ; - scope - dependency scope
                      ; - optional - flag showing whether a dependency is optional, any value but "" and "no" is considered to be true
                      ; - classifier - dependency Maven-classifier
                      ; - extension - dependency Maven-extension
                      ; - exclusions - list of transient dependency exclusions for a dependency
                      (make-dependency (name version scope optional classifier extension exclusions)
                                       (let ((new-dep (make-hash-table)))
                                         (puthash 'name name new-dep)
                                         (puthash 'version (format "%s" version) new-dep)
                                         (puthash 'scope scope new-dep)
                                         (puthash 'optional (if (or
                                                                 (string-empty-p optional)
                                                                 (string= "no" (downcase optional)))
                                                                nil
                                                              't)
                                                  new-dep)
                                         (puthash 'classifier classifier new-dep)
                                         (puthash 'extension  extension  new-dep)
                                         (puthash 'exclusions exclusions new-dep)
                                         new-dep))
                      ; Dependency serializing function
                      (serialize-dependency (dependency)
                                            (concat "["
                                                    ; Traversing every key in the dependency hash table and building dependency definition string
                                                    (mapconcat (lambda (key)
                                                                 (let ((value (gethash key dependency)))
                                                                      (cond
                                                                        ; name is always given
                                                                        ((equal key 'name)
                                                                            value)
                                                                              ; I'm not sure but maybe version might be empty
                                                                        ((and (equal key 'version) (not (string-empty-p value)))
                                                                            (format "\"%s\"" value))
                                                                              ; Scope is optional
                                                                        ((and (equal key 'scope) (not (string-empty-p value)))
                                                                            (format ":scope \"%s\"" value))
                                                                              ; Optional flag should be set only if it's true
                                                                        ((and (equal key 'optional) value)
                                                                            ":optional true")
                                                                              ; Classifier is optinal
                                                                        ((and (equal key 'classifier) (not (string-empty-p value)))
                                                                            (format ":classifier \"%s\"" value))
                                                                              ; Extension is optional
                                                                        ((and (equal key 'extension) (not (string-empty-p value)))
                                                                            (format ":extension \"%s\"" value))
                                                                              ; Exclusions should be given if there're any
                                                                        ((and (equal key 'exclusions) (not (seq-empty-p value)))
                                                                            (concat
                                                                                ":exclusions ["
                                                                                (mapconcat #'serialize-dependency value " ")
                                                                                "]")))))
                                                               serialize-key-traversing-seq
                                                               " ")
                                                    "]")))
              (let (
                    ; deps-adopted is a list of hash tables representing dependencies
                    (deps-adopted (reduce
                                    (lambda (deps-adopted dependency)
                                      ; Skip any hlines and empty rows
                                      (if (or (equal dependency 'hline) (every #'string-empty-p dependency))
                                          deps-adopted
                                        ; Else destructuring the dependency given
                                        (destructuring-bind (name version scope optional classifier extension exclusions ex-classifier ex-extension _) dependency
                                          (cond
                                           ; Append new dependency hash map in case there's a name given
                                           ((not (string-empty-p name))
                                            (append deps-adopted
                                                    (list (make-dependency name
                                                                           version
                                                                           scope
                                                                           optional
                                                                           classifier
                                                                           extension
                                                                           (if (not (string-empty-p exclusions))
                                                                               (list (make-dependency exclusions
                                                                                                      ""
                                                                                                      ""
                                                                                                      ""
                                                                                                      ex-classifier
                                                                                                      ex-extension
                                                                                                      nil)))))))
                                           ; Append another exclusion in case there's no name but exclusions given
                                           ((and (string-empty-p name) (not (string-empty-p exclusions)))
                                            (let* ((last-dep (car (last deps-adopted))))
                                              (puthash 'exclusions
                                                       (append (gethash 'exclusions last-dep nil)
                                                               (list (make-dependency exclusions
                                                                                      ""
                                                                                      ""
                                                                                      ""
                                                                                      ex-classifier
                                                                                      ex-extension
                                                                                      nil)))
                                                       last-dep)
                                              deps-adopted))))))
                                    ; Skipping title line
                                    (cdr deps-table)
                                    :initial-value nil)))
                ; So now I have list of dependencies (as hash maps) which I'm to transform into Clojure's vector of vectors
                ; in Clojure syntax
                (mapconcat #'serialize-dependency deps-adopted "\n"))))))
  #+END_SRC

* render-code-block-if

  Выводит результат работы блока кода если в спецификации проекта присутствует параметр с требуемым значением.

  *Требования*:
  - Блок кода с данным именем должен присутствовать в org-файле из которого делается вызов

  *Примеры:*
  #+BEGIN_EXAMPLE
    <<render-codeblock-if(name="project-clojurescript-dependencies" if="ClojureScript=yes")>>
    #+CALL: render-codeblock-if(name="project-clojurescript-dependencies" if="ClojureScript=yes")
  #+END_EXAMPLE

  #+CAPTION: *Параметры:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Имя       | Значение по умолчанию | Описание                                                                        |
  |-----------+-----------------------+---------------------------------------------------------------------------------|
  | name      | ""                    | Имя блока присвоенное через диррективу ~#+NAME:~.                               |
  | condition | ""                    | Условие вывода в формате "ПАРАМЕТР = ЗНАЧЕНИЕ", где = операция сравнения строк. |

  #+NAME: render-codeblock-if
  #+BEGIN_SRC emacs-lisp :var name="" :var condition="" :results value silent
        (save-excursion
          (destructuring-bind (&optional (param-name "") &optional (cond-value "")) (split-string condition "=" t "\s+")
            (let ((param-value (org-babel-execute-src-block
                                nil
                                (cdr (assoc 'get-specification-param org-babel-library-of-babel))
                                (list
                                 (cons :var (format "title=\"%s\"" param-name))))))
              (if (string= param-value cond-value)
                  (progn
                    (org-babel-goto-named-src-block name)
                    (let ((tangle-result (org-babel-tangle-single-block "")))
                      (nth 5 tangle-result)))
                ""))))
  #+END_SRC
