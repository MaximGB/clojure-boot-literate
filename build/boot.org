#+SETUPFILE: setup.org

* boot.properties

  Файл boot.properties используется Boot для привязки проекта к конкретной версии Boot и запуска этой версии Boot
  на конкретной версии Clojure.

  #+NAME: boot.properties
  #+BEGIN_SRC sh :tangle ../boot.properties :noweb yes
    #http://boot-clj.com
    #<<time-is-now()>>
    BOOT_CLOJURE_NAME=org.clojure/clojure
    BOOT_CLOJURE_VERSION=<<get-specification-param(title="Clojure/Версия")>>
    BOOT_VERSION=<<get-specification-param(title="Boot/Версия")>>
  #+END_SRC

* build.boot

  Файл ~build.boot~ исполняется Boot при запуске src_sh{boot task}, где ~task~ имя задачи для исполнения. Задачи проекта
  описаны ниже, в соответствующем разделе.

  #+NAME: build.boot
  #+BEGIN_SRC clojure :tangle ../build.boot :noweb yes :exports none
    (require '[clojure.java.io :refer [file]])

    <<set-project-paths>>

    <<render-codeblock-if(name="set-project-clojure-dependency", condition="Clojure=yes")>>

    <<render-codeblock-if(name="set-project-clojurescript-dependency", condition="ClojureScript=yes")>>

    <<set-project-user-dependencies>>

    <<render-codeblock-if(name="boot-clojure-tasks", condition="Clojure=yes")>>

    <<render-codeblock-if(name="boot-clojurescript-tasks", condition="ClojureScript=yes")>>

    <<boot-user-task>>
  #+END_SRC

  Устанавливаем дирректории проекта, если они объявлены в спецификации и присутствуют на диске.

  #+NAME: set-project-paths
  #+BEGIN_SRC clojure
    (def paths [ [:source-paths "<<get-specification-param(title="Clojure/Расположение исходников")>>"]
                 [:source-paths "<<get-specification-param(title="ClojureScript/Расположение исходников")>>"]
                 [:resource-paths "<<get-specification-param(title="Расположение classpath ресурсов")>>"]
                 [:asset-paths "<<get-specification-param(title="Расположение прочих ресурсов")>>"] ] )

    (doseq [[ env-key path ] paths]
      (if (and (seq path) (not ((get-env env-key) path)))
        (let [dir (file path)]
          (if (.isDirectory dir)
            (set-env! env-key #(conj % (.getName dir)))))))
  #+END_SRC

  Если в проекте объявлена зависимость от /Clojure/, т.е. в спецификации для параметра ~Clojure~ указано ~yes~,
  то добавляем зависимость от /Clojure/.

  #+NAME: set-project-clojure-dependency
  #+BEGIN_SRC clojure
    (set-env! :dependencies #(conj % '[org.clojure/clojure "<<get-specification-param(title="Clojure/Версия")>>"]))
  #+END_SRC

  Если в проекте объявлена зависимость от /ClojureScript/, т.е. в спецификации для параметра ~ClojureScript~
  указано ~yes~, то добавляем зависимость от /ClojureScript/.

  #+NAME: set-project-clojurescript-dependency
  #+BEGIN_SRC clojure
    (set-env! :dependencies #(conj % '[org.clojure/clojurescript "<<get-specification-param(title="ClojureScript/Версия")>>"]))
  #+END_SRC

  Добавляем пользовательские зависимости проекта.

  #+NAME: set-project-user-dependencies
  #+BEGIN_SRC clojure
    (let [deps '[
                <<render-project-dependencies()>>
               ]]
      (set-env! :dependencies #(into % deps)))
  #+END_SRC

** Boot-задачи проекта для /Clojure/

   Boot-задачи для /Clojure/ будут добавлены в результирующий ~build.boot~, если в спецификации проекта в параметре
   ~Clojure~ указано значение ~yes~.

   Все блоки кода с boot-задачами для /Clojure/ должны иметь имя ~boot-clojure-task~. Каждая задача с таким именем будет
   включена в результирующий ~build.boot~.

   #+NAME: boot-clojure-tasks
   #+BEGIN_SRC clojure :noweb yes :exports none
     <<boot-clojure-task>>
   #+END_SRC

*** clj-build
    :PROPERTIES:
    :CUSTOM_ID: clj-build
    :END:

    Эта задача строит uberjar проекта который запускается командой.

    #+BEGIN_SRC sh :dir ".." :noweb yes
      java -jar <<get-specification-param(title="Целевая дирректория")>>/project.jar
    #+END_SRC

    #+NAME: boot-clojure-task
    #+BEGIN_SRC clojure
      (deftask clj-build
        "Builds project's uberjar"
        []
        (comp (pom :project '<<get-specification-param(title="Имя проекта")>>
                   :version "<<get-specification-param(title="Версия проекта")>>")
              (aot :all true)
              (uber)
              (jar :main '<<get-specification-param(title="Имя проекта", splitby="/", joinby=".")>>.<<get-specification-param(title="Пространство имён main")>>)
              (target :dir #{"<<get-specification-param(title="Целевая дирректория")>>"})))
    #+END_SRC

    Для вызова задачи выполните: src_sh[:dir ".."]{boot clj-build}

*** clj-run

    Эта задача запускает проект в той же Java-среде в которой запущен Boot. Перед запуском надо скомпелировать проект
    задачей [[#clj-build][clj-build]].

    #+NAME: boot-clojure-task
    #+BEGIN_SRC clojure
      (deftask clj-run
        "Runs the project's main function"
        []
        (require '<<get-specification-param(title="Имя проекта", splitby="/", joinby=".")>>.<<get-specification-param(title="Пространство имён main")>>)
        (let [main-fn (resolve '<<get-specification-param(title="Имя проекта", splitby="/", joinby=".")>>.<<get-specification-param(title="Пространство имён main")>>/-main)]
          (comp (aot :all true) (with-pass-thru _ (main-fn)))))
    #+END_SRC

    Для вызова задачи выполните: src_sh[:dir ".."]{boot clj-run}

** Boot-задачи проекта для /ClojureScript/

   Boot-задачи для /ClojureScript/ будут добавлены в результирующий ~build.boot~, если в спецификации проекта
   в параметре ~ClojureScript~ указано значение ~yes~.

   Все блоки кода с boot-задачами для /ClojureScript/ должны иметь имя ~boot-clojurescript-task~. Каждая задача с таким
   именем будет включена в результирующий ~build.boot~.

   #+NAME: boot-clojurescript-tasks
   #+BEGIN_SRC clojure :noweb yes :exports none
     <<boot-clojurescript-task>>
   #+END_SRC

*** cljs-figwheel

    Эта задача интерфейс к *figwheel*, для запуска используйте src_sh[:dir "."]{boot cljs-figwheel}.\\

    Компилирует ClojureScript файлы, запускает HTTP-server обслуживающий дирректорию публичных ресурсов,
    запускает монитор для перекомпиляции, запускает nRepl сервер. Для входа в ClojureScript REPL выполнить
    "9 шагов к успеху":

    1. выполнить src_sh{boot cljs-figwheel}
    2. дождаться звукового сигнала
    3. посмотреть в консоли адрес и порт запущенного веб-сервера (обычно http://localhost:3449)
    4. открыть браузер, открыть URL, увидеть в JavaScript-консоли сообщение Opened Websocket REPL connection
    5. посмотреть в консоли адрес и порт nRepl сервера, передать их в следующем шаге
    6. выполнить src_emacs-lisp{(cider-connect HOST PORT)} или M-x cider-connect и ввести HOST и PORT, хотя, походу
       cider сам прекрасно всё цепляет из файла ~.nrepl-port~, так что можно просто два раза ENTER нажать
    7. в REPL буфере ввести src_clojure{(cljs-repl)} чтобы запустить ClojureScript REPL
    8. в REPL буфере ввести src_clojure{(.log js/console "OK!")}
    9. увидеть сообщение "OK!" в JavaScript-консоли браузера

    #+NAME: boot-clojurescript-task
    #+BEGIN_SRC clojure
      (set-env! :dependencies #(into % '[[ajchemist/boot-figwheel "0.5.4-6" :scope "test"]
                                         [org.clojure/tools.nrepl "0.2.12" :scope "test"]
                                         [com.cemerick/piggieback "0.2.1" :scope "test"]
                                         [figwheel-sidecar "0.5.7" :scope "test"]]))

      (require '[boot-figwheel :refer [figwheel start-figwheel! stop-figwheel! start-autobuild stop-autobuild cljs-repl fig-status]])

      ;; This is for (cider-connect) to work.
      ;; NOTE: do not use (cider-jack-in), use (cider-connect) instead
      ;; ---------------------------
      ;; Start of cider related code
      (swap! boot.repl/*default-dependencies* concat '[[cider/cider-nrepl "<<get-specification-param(title="Cider/Версия")>>"]])
      (swap! boot.repl/*default-middleware* conj 'cider.nrepl/cider-middleware)
      ;; End of cider related code

      (deftask cljs-figwheel
        "Compiles ClojureScript, serves it, autobuilds"
        []
        (comp
         (figwheel :build-ids ["dev"]
                   ;:once-build ["advanced"]
                   :all-builds [{:id "dev"
                                 :source-paths (seq (get-env :source-paths))
                                 :compiler {:main '<<get-specification-param(title="Имя проекта", splitby="/", joinby=".")>>.<<get-specification-param(title="Пространство имён main")>>
                                            :optimizations :none
                                            :source-map true
                                            :output-to "app.js"}
                                 :figwheel {:build-id "dev"
                                            :on-jsload '<<get-specification-param(title="Имя проекта", splitby="/", joinby=".")>>.<<get-specification-param(title="Пространство имён main")>>/-main
                                            :heads-up-display true
                                            :autoload true
                                            :debug false}}]
                   :figwheel-options {:http-server-root "public"
                                      :open-file-command "emacsclient"
                                      :repl false}
                   :target-path "<<get-specification-param(title="Расположение публичных ресурсов")>>")
         (speak)
         (repl)))
    #+END_SRC

** Пользовательские boot-задачи

   Все блоки кода с пользовательскими boot-задачами должны иметь имя ~boot-user-task~. Каждая задача с таким
   именем будет включена в результирующий ~build.boot~.
