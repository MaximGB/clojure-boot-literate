#+TITLE: Clojure/ClojureScript Boot literate programming template
#+SETUPFILE: build/setup.org

* Table of contents                                      :noexport:TOC_4_org:
 - [[Quick start][Quick start]]
 - [[Project specification][Project specification]]
   - [[Dependencies][Dependencies]]
 - [[Environment and project requirements][Environment and project requirements]]
 - [["Library of Babel" helper code blocks library]["Library of Babel" helper code blocks library]]
 - [[Boot-project][Boot-project]]
 - [[Project code][Project code]]
 - [[Footnotes][Footnotes]]

* Quick start

  - Load project *Library of Babel*, by executing the following code block
    src_emacs-lisp[]{(org-babel-lob-ingest "build/lob.org")}, to execute it place the cursor on the block
    and press C-c C-c.
  - Fill in the table in the [[#project-specification][Project specification]] section.
  - Read the [[#env-requirements][Environment and project requirements]] section, setup your environment accordingly and create
    the code exporting scripts ~tangle.sh~ and ~tangle-all.sh~.
  - Export initial project code by runing src_sh[]{./tangle-all.sh}, place the cursor on
    the code block and press C-c C-c to execute it from *Emacs*, or run ~tangle-all.sh~ from a terminal.
  - Build the project with *Boot*:
    - For *Clojure* src_sh[]{boot clj-build}, place the cursor on the code block and press C-c C-c to execute it,
      or run ~boot clj-build~ from a terminal.
    - For *ClojureScript* src_sh[]{boot cljs-figwheel}, place the cursor on the code block and
      press C-c C-c to execute it, or run ~boot cljs-figwheel~ from a terminal.
  - Run the project by running
    src_sh[:dir "." :noweb yes]{java -jar <<get-specification-param(title="Target path")>>/project.jar},
    place the cursor on the code block and press C-c C-c, or run ~java jar target/project.jar~ from a terminal.
  - Keep working on the project export the code periodically.
  - To export the project documentation:
    - Into ~project.pdf~ press С-с С-e l p.
    - Into ~project.html~ press C-c C-e h h.

* Project specification
  :PROPERTIES:
  :CUSTOM_ID: project-specification
  :END:

  Project specification is given in the table following. The project file system as well as ~boot.properties~
  and ~build.boot~ files are generated according to the specification.

  #+CAPTION: Project specification
  #+NAME: project-specification
  | Property              | Value            |
  |-----------------------+------------------|
  | Boot                  |                  |
  |-----------------------+------------------|
  | Version               | 2.6.0            |
  |-----------------------+------------------|
  | Project name          | literate-boot    |
  | Project version       | 0.1.0-SNAPSHOT   |
  | Org sources path      | org              |
  | Tests path            | tests            |
  | Resource path         | resources        |
  | Assets path           | assets           |
  | Target path           | target           |
  | Main namespace        | core             |
  |-----------------------+------------------|
  | Clojure               | yes              |
  |-----------------------+------------------|
  | Version               | 1.8.0            |
  | Sources path          | src              |
  |-----------------------+------------------|
  | ClojureScript         | yes              |
  |-----------------------+------------------|
  | Version               | 1.9.225          |
  | Sources path          | src              |
  | Public resources path | resources/public |
  |-----------------------+------------------|
  | Cider                 |                  |
  |-----------------------+------------------|
  | Version               | 0.14.0           |

** Dependencies
   :PROPERTIES:
   :CUSTOM_ID: project-dependencies
   :END:
   Project dependencies are given in the *dependencies* table\\

   One dependency per the table row should be given. The table columns correspond to options supported by [[https://github.com/cemerick/pomegranate][pomegranate]]
   library, which in it's turn, is used by *Boot* for dependecies resolution [fn:1]:

   * *Name*       - artifact name
   * *Version*    - artifact version
   * *Scope*      - dependency scope (in Maven terms), mighe be one of: ~compile, provided, runtime, test, system, import~
   * *Optional*   - dependency optionality flag, any dependency having ~no~ or empty value in this column
                    is considired to be optional
   * *Classifier* - dependency classifier (in Maven terms)
   * *Extension*  - dependency extension (in Maven-terms)
   * *Exclusion*  - transitive dependencies exclusions for the dependency, one exclusion per the table row is allowed
                    if you need to setup several exclusions for one dependency than for second and other exclusions
                    *name*, *version*, *scope*, *optional*, *classifier*, *extension* columns should be empty
   * *Classifier* - exclusion dependency classifier (in Maven terms)
   * *Extension*  - exclusion dependency extension (in Maven-terms)
   * *Note*       - this column is ignored, it's used for documentation purposes

  #+CAPTION: Dependencies
  #+ATTR_LATEX: :width \textwidth :align |l|r|r|c|r|r|l|r|r|l| :float nil
  #+NAME: project-dependencies
  | Name | Version | Scope | Optional | Classifier | Extension | Exclusion | Classifier | Extension | Note |
  |------+---------+-------+----------+------------+-----------+-----------+------------+-----------+------|

* Environment and project requirements
  :PROPERTIES:
  :CUSTOM_ID: env-requirements
  :END:

  #+SETUPFILE: setup.org
  
** Environtment

  This project template requires Emacs/Org-mode, Clojure, Boot. The project which might be built using this template
  will follow principles of the literate programming, i.e. when program code is extracted from Org files,
  which in turn combine a project documentation and code.

** Code export from org-files.

  To exctract code from org-files into files with *Clojure* source code ~tangle.sh~ file is used [fn:-1-thi-ng-credit].

  Unfortunatelly it's impossible to export code  from Emacs by simply executing *M-x org-babel-tangle*
  call out of the box using this template. The project org-files are using the so called *"Library of Babel"* feature,
  the code of which is inside ~build/lob.org~ file. To initialize the library a call to ~(org-babel-lob-ingest)~
  is required. This call is done inside ~tangle.sh~ file and if you run it from a terminal everything should work
  out of the box. To export code from Emacs you will have to execute src_emacs-lisp{(org-babel-lib-ingest "build/lob.org")}
  call once per session (Emacs run).

  To create ~tangle.sh~ file in the project's root directory place the cursor into the following source code block
  and press C-u C-c C-v t, this will put the code block contents into ~tangle.sh~ file on your disk.

  #+NAME: tangle.sh
  #+BEGIN_SRC shell :tangle ../tangle.sh  :shebang "#!/bin/sh" :noweb yes :results silent
    DIR=`pwd`
    FILES=""

    # wrap each argument in the code required to call tangle on it
    for i in $@; do
        FILES="$FILES \"$i\""
    done

    emacs -Q --batch \
        --eval \
        "(progn
           (require 'package)
           (let ((default-directory package-user-dir))
             (normal-top-level-add-subdirs-to-load-path))
           (require 'cl)(require 'org)(require 'ob)(require 'ob-tangle)(require 'ob-lob)
           (org-babel-lob-ingest \"build/lob.org\")
           (setq org-confirm-babel-evaluate nil)
           (mapc (lambda (file)
                  (find-file (expand-file-name file \"$DIR\"))
                  (org-babel-tangle)
                  (kill-buffer)) '($FILES)))" \
    2>&1 | grep Tangled
  #+END_SRC

  This script receives org-file names which to extract source code from: src_sh{tangle.sh file ...}, where ~file~ is
  name or names of org-files to process.

** Project code export

  To extract project source code from all org-files the ~tangle-all.sh~ shell-script is used [fn:-1-thi-ng-credit].

  To create ~tangle-all.sh~ file in the project's root directory place the cursor into the following source code block
  and press C-u C-c C-v t, this will put the code block contents into ~tangle-all.sh~ file on your disk.

  #+NAME: tangle-all.sh
  #+BEGIN_SRC shell :tangle ../tangle-all.sh  :shebang "#!/bin/sh" :noweb yes :results silent
    ./tangle.sh project.org build/*.org <<get-specification-param(title="Org sources path")>>/*.org
  #+END_SRC

[fn:-1-thi-ng-credit] ~tangle.sh~ and ~tangle-all.sh~ shell-script has been taken from [[https://github.com/thi-ng/babel][thi.ng/babel]] project and adopted to this project a bit.

* "Library of Babel" helper code blocks library

  Helper code blocks constituting the project's *"Library of Babel"* are defined. This code blocks work in *Emacs/Org*
  environment and are not supposed to be called from Clojure or ClojureScript.
  
** time-is-now

  Returns current time as a string in a given format.

  *Examples:*
  #+BEGIN_EXAMPLE
    <<time-is-now()>>
    <<time-is-now(format="%F")
    #+CALL: time-is-now()
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name     | Default value | Description                                                                   |
  |----------+---------------+-------------------------------------------------------------------------------|
  | [format] | "%F %X"       | Time string format as supported by ~(format-time-string)~ function. Optional. |

  #+NAME: time-is-now
  #+BEGIN_SRC emacs-lisp :var format="%F %X" :results value silent
    (format-time-string format)
  #+END_SRC

** get-table-param
  :PROPERTIES:
  :CUSTOM_ID: lob-get-table-param
  :END:

  Returns a value of a parameter defined in a table. Table must follow given requirements: parameter names are given
  in the first column, parameter values - in the second column. Hierarchical queries are supported in a way,
  if parameter name is given as ~name/subname~ then first ~name~ will be searched and then ~subname~ will be searched
  starting from ~name~ a row where ~name~ has been found.

  *Examples:*
  #+BEGIN_EXAMPLE
    <<get-table-param(table=../project.org:project-specification, title="Project name")>>
    <<get-table-param(table=../project.org:project-specification, title="Project name", splitby="-", joinby="_")>>
    <<get-table param(table=../project.org:project-specification, title="Clojure/Version")>>
    #+CALL: get-table-param(table=../project.org:project-specification, title="Project name")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name      | Default value | Description                                                                           |
  |-----------+---------------+---------------------------------------------------------------------------------------|
  | table     | (quote ())    | Table reference. Reference format is ~[table containing org-file path:]table-name~,   |
  |           |               | for example ~../file.org:table_name~ or just ~table_name~ if a table is given         |
  |           |               | in the same file the call is done from. Default value simply allows return nil if     |
  |           |               | parameter is not given, since internally code block receives a table as a list.       |
  |-----------+---------------+---------------------------------------------------------------------------------------|
  | title     | ""            | Parameter name. Path-like parameter names are supported (i.e. names containing ~'/'~. |
  |           |               | If such /complex/ parameter is given, than it'll be splited, and each resulting part  |
  |           |               | will be considered as a separate parameter name. The following parameter name search  |
  |           |               | will be started from a row where the preceding parameter name has been found, a value |
  |           |               | of a preceding parameter is ignored. A value of the last parameter will be returned.  |
  |-----------+---------------+---------------------------------------------------------------------------------------|
  | [splitby] | ""            | Parameter value splitter. Optional. Works in pair with ~joinby~. If parameter values  |
  |           |               | a listed in a cell as comma-separated list, for example, than, giving ~splitby=","~,  |
  |           |               | will split'em, and splitted values will be joined with ~joinby~ value.                |
  |-----------+---------------+---------------------------------------------------------------------------------------|
  | [joinby]  | ""            | Parameter value combinator. Optional. Works in pair with ~splitby~.                   |

  #+NAME: get-table-param
  #+BEGIN_SRC emacs-lisp :var table=(quote ()) :var title="" :var splitby="" :var joinby="" :hlines yes :results value silent
    (let* ((table-adopted (mapcar (lambda (x)
                                    (if (equal x 'hline)
                                       '(hline hline hline)
                                     x))
                                  table))
           (titles (mapcar #'car table-adopted))
           (path (split-string title (regexp-quote "/")))
           (last-index (reduce (lambda (index title)
                                 (cl-position title titles :start index :test #'equal))
                               path
                               :initial-value nil)))
      (if last-index
          (let* ((result (nth 1 (nth last-index table-adopted))))
            (if (and result splitby joinby)
                (mapconcat #'identity (split-string result (regexp-quote splitby) t "\s+") joinby)
              result))))
  #+END_SRC

** get-specification-param

  Returns parameter value given in [[#project-specification][the project specification table]] inside ~../project.org~ file.

  *Examples:*
  #+BEGIN_EXAMPLE
    <<get-specification-param(title="Project name")>>
    <<get-specification-param(title="Main namespace", splitby="." joinby="/")>>
    #+CALL: get-specification-param(title="Project name")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name      | Default value | Description                                          |
  |-----------+---------------+------------------------------------------------------|
  | title     | ""            | Parameter name (see [[#lob-get-table-param][(get-table-param)]]).           |
  | [splitby] | ""            | Parameter value separator (see [[#lob-get-table-param][(get-table-param)]]).   |
  | [joinby]  | ""            | Parameter value combinator (see. [[#lob-get-table-param][(get-table-param)]]). |

  #+NAME: get-specification-param
  #+BEGIN_SRC emacs-lisp :var title="" :var splitby="" :var joinby="" :results value silent
    (save-excursion
      (let ((project-org-dir (locate-dominating-file (buffer-file-name) "project.org")))
           (if project-org-dir
             (let ((project-spec-ref (concat project-org-dir "project.org:project-specification")))
                  (org-babel-execute-src-block
                    nil
                    (cdr (assoc 'get-table-param org-babel-library-of-babel))
                    (list
                      (cons :var (format "table=%s" project-spec-ref))
                      (cons :var (format "title=\"%s\"" title))
                      (cons :var (format "splitby=\"%s\"" splitby))
                      (cons :var (format "joinby=\"%s\""  joinby))))))))
  #+END_SRC

** in-some-path

  Returns an absolute path to a file in one of the project directories given in [[#project-specification][the project specification table]],
  will take project name into account and insert it as intermediate directory if requested.

  *Requirements*: Project specification must have following parameters defined:
  - Project name
  - Parameter given in ~param~ code block parameter.

  *Examples:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-some-path (param="Clojure/Sources path" path \"core.clj\"))
       ...
    #+END_SRC
    <<in-some-path(param="Clojure/Sources path", path="core.clj")>>
    #+CALL: in-some-path(param="Clojure/Sources path", path="core.clj")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{8cm}| :float nil
  | Name          | Default value          | Description                                                             |
  |---------------+------------------------+-------------------------------------------------------------------------|
  | param         | "Clojure/Sources path" | Parameter name defining the base directory (relative to project root)   |
  | [path]        | ""                     | Path relative to built directory name                                   |
  | [projectvise] | t                      | Whether to insert project name between base directory path and the path |
  |               |                        | part given in ~path~ parameter                                          |

  #+NAME: in-some-path
  #+BEGIN_SRC emacs-lisp :var param="Clojure/Sources path" :var path="" :var projectvise='t :results value silent
    (save-excursion
      (let* ((project-org-dir (locate-dominating-file (buffer-file-name) "project.org"))
             (src-path (org-babel-execute-src-block
                         nil
                         (cdr (assoc 'get-specification-param org-babel-library-of-babel))
                         (list
                           (cons :var (format "title=\"%s\"" param)))))
             (project-name (org-babel-execute-src-block
                             nil
                             (cdr (assoc 'get-specification-param org-babel-library-of-babel))
                             (list
                               (cons :var "title=\"Project name\"")
                               (cons :var "splitby=\".\"")
                               (cons :var "joinby=\"/\""))))
             (ns-path (replace-regexp-in-string "\-" "_" project-name)))
            (concat project-org-dir src-path "/" (if projectvise (concat ns-path "/") "") path)))
  #+END_SRC

** in-clj-path

  Return an absolute path to a file in project's exported *Clojure* sources directory with respect to project name.

  *Requirements*: Project specification must have following parameters defined:
  - Project name
  - Clojure/Sources path

  *Examples:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-clj-path (path \"core.clj\"))
       ...
    #+END_SRC
    <<in-clj-path(path="core.clj")>>
    #+CALL: in-clj-path(path="core.clj")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name | Default value | Description                                                                  |
  |------+---------------+------------------------------------------------------------------------------|
  | path | ""            | Path relative to project's exported Clojure sources directory to be appended |

  #+NAME: in-clj-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Clojure/Sources path\"")
         (cons :var (format "path=\"%s\"" path)))))
  #+END_SRC

** in-cljs-path

  Return an absolute path to a file in project's exported *Clojure Script* sources directory with respect to project name.

  *Requirements*: Project specification must have following parameters defined:
  - Project name
  - ClojureScript/Sources path

  *Examples:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-cljs-path (path \"core.clj\"))
       ...
    #+END_SRC
    <<in-cljs-path(path="core.clj")>>
    #+CALL: in-cljs-path(path="core.clj")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name | Default value | Description                                                                         |
  |------+---------------+-------------------------------------------------------------------------------------|
  | path | ""            | Path relative to project's exported Clojure Script sources directory to be appended |

  #+NAME: in-cljs-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"ClojureScript/Sources path\"")
         (cons :var (format "path=\"%s\"" path)))))
  #+END_SRC

** in-tests-path

  Return an absolute path to a file in project's exported tests sources directory with respect to project name.

  *Requirements*: Project specification must have following parameters defined:
  - Project name
  - Tests path

  *Examples:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-tests-path (path \"core.clj\"))
       ...
    #+END_SRC
    <<in-tests-path(path="core.clj")>>
    #+CALL: in-tests-path(path="core.clj")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name | Default value | Description                                                        |
  |------+---------------+--------------------------------------------------------------------|
  | path | ""            | Path relative to project's exported tests directory to be appended |

  #+NAME: in-tests-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Tests path\"")
         (cons :var (format "path=\"%s\"" path)))))
  #+END_SRC

** in-resources-path

  Return an absolute path to a file in project's exported resources directory.

  *Requirements*: Project specification must have following parameters defined:
  - Project name
  - Resource path

  *Examples:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-resources-path (path \"index.html"))
       ...
    #+END_SRC
    <<in-resources-path(path="index.html")>>
    #+CALL: in-resources-path(path="index.html")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name | Default value | Description                                                              |
  |------+---------------+--------------------------------------------------------------------------|
  | path | ""            | A path relative to project's exported resources directory to be appended |

  #+NAME: in-resources-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Resource path\"")
         (cons :var (format "path=\"%s\"" path))
         (cons :var "projectvise=()"))))
  #+END_SRC

** in-assets-path

  Return an absolute path to a file in project's exported assets directory.

  *Requirements*: Project specification must have following parameters defined:
  - Project name
  - Assets path

  *Examples:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-resources-path (path \"index.html"))
       ...
    #+END_SRC
    <<in-resources-path(path="index.html")>>
    #+CALL: in-resources-path(path="index.html")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name | Default value | Description                                                           |
  |------+---------------+-----------------------------------------------------------------------|
  | path | ""            | A path relative to project's exported assets directory to be appended |

  #+NAME: in-assets-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Assets path\"")
         (cons :var (format "path=\"%s\"" path))
         (cons :var "projectvise=()"))))
  #+END_SRC

** in-target-path

  Returns an absolute path to a file in project's target directory.

  *Requirements*: Project specification must have following parameters defined:
  - Project name
  - Target path

  *Examples:*
  #+BEGIN_EXAMPLE
    #+BEGIN_SRC clojure :tangle (org-sbe in-target-path (path \"project.jar"))
       ...
    #+END_SRC
    <<in-target-path(path="project.jar")>>
    #+CALL: in-target-path(path="project.jar")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name | Default value | Description                                                  |
  |------+---------------+--------------------------------------------------------------|
  | path | ""            | A path relative to project's target directory to be appended |

  #+NAME: in-target-path
  #+BEGIN_SRC emacs-lisp :var path="" :results value silent
    (save-excursion
      (org-babel-execute-src-block
        nil
        (cdr (assoc 'in-some-path org-babel-library-of-babel))
        (list
         (cons :var "param=\"Target path\"")
         (cons :var (format "path=\"%s\"" path))
         (cons :var "projectvise=()"))))
  #+END_SRC

** render-project-dependencies

  Renders (returns as a string) project dependencies, defined in [[#project-dependencies][the project dependencies table]],
  as a list of *Clojure* vectors.

  *Examples:*
  #+BEGIN_EXAMPLE
    <<render-project-dependencies()>>
    #+CALL: render-project-dependencies()
    (org-sbe render-project-dependencies)
  #+END_EXAMPLE

  #+NAME: render-project-dependencies
  #+BEGIN_SRC emacs-lisp :results value silent
    ; Full dependency definition specification is given here
    ; https://github.com/cemerick/pomegranate/blob/master/src/main/clojure/cemerick/pomegranate/aether.clj
    ; in resolve-dependencies function
    (require 'subr-x)
    (require 'seq)

    (let ((project-org-dir (locate-dominating-file (buffer-file-name) "project.org")))
      (if project-org-dir
          (let* ((project-spec-ref (concat project-org-dir "project.org:project-dependencies"))
                 ; deps-table is a list of lists and hlines
                 (deps-table (org-babel-ref-resolve project-spec-ref))
                 ; Dependency representing hash-map key traversing sequence
                 (serialize-key-traversing-seq '(name version scope optional classifier extension exclusions)))
            (cl-labels (
                      ; dependency hash map has following keys
                      ; - name - dependency artifact name
                      ; - version - dependency artifact version
                      ; - scope - dependency scope
                      ; - optional - flag showing whether a dependency is optional, any value but "" and "no" is considered to be true
                      ; - classifier - dependency Maven-classifier
                      ; - extension - dependency Maven-extension
                      ; - exclusions - list of transient dependency exclusions for a dependency
                      (make-dependency (name version scope optional classifier extension exclusions)
                                       (let ((new-dep (make-hash-table)))
                                         (puthash 'name name new-dep)
                                         (puthash 'version (format "%s" version) new-dep)
                                         (puthash 'scope scope new-dep)
                                         (puthash 'optional (if (or
                                                                 (string-empty-p optional)
                                                                 (string= "no" (downcase optional)))
                                                                nil
                                                              't)
                                                  new-dep)
                                         (puthash 'classifier classifier new-dep)
                                         (puthash 'extension  extension  new-dep)
                                         (puthash 'exclusions exclusions new-dep)
                                         new-dep))
                      ; Dependency serializing function
                      (serialize-dependency (dependency)
                                            (concat "["
                                                    ; Traversing every key in the dependency hash table and building dependency definition string
                                                    (mapconcat (lambda (key)
                                                                 (let ((value (gethash key dependency)))
                                                                      (cond
                                                                        ; name is always given
                                                                        ((equal key 'name)
                                                                            value)
                                                                              ; I'm not sure but maybe version might be empty
                                                                        ((and (equal key 'version) (not (string-empty-p value)))
                                                                            (format "\"%s\"" value))
                                                                              ; Scope is optional
                                                                        ((and (equal key 'scope) (not (string-empty-p value)))
                                                                            (format ":scope \"%s\"" value))
                                                                              ; Optional flag should be set only if it's true
                                                                        ((and (equal key 'optional) value)
                                                                            ":optional true")
                                                                              ; Classifier is optinal
                                                                        ((and (equal key 'classifier) (not (string-empty-p value)))
                                                                            (format ":classifier \"%s\"" value))
                                                                              ; Extension is optional
                                                                        ((and (equal key 'extension) (not (string-empty-p value)))
                                                                            (format ":extension \"%s\"" value))
                                                                              ; Exclusions should be given if there're any
                                                                        ((and (equal key 'exclusions) (not (seq-empty-p value)))
                                                                            (concat
                                                                                ":exclusions ["
                                                                                (mapconcat #'serialize-dependency value " ")
                                                                                "]")))))
                                                               serialize-key-traversing-seq
                                                               " ")
                                                    "]")))
              (let (
                    ; deps-adopted is a list of hash tables representing dependencies
                    (deps-adopted (reduce
                                    (lambda (deps-adopted dependency)
                                      ; Skip any hlines and empty rows
                                      (if (or (equal dependency 'hline) (every #'string-empty-p dependency))
                                          deps-adopted
                                        ; Else destructuring the dependency given
                                        (destructuring-bind (name version scope optional classifier extension exclusions ex-classifier ex-extension _) dependency
                                          (cond
                                           ; Append new dependency hash map in case there's a name given
                                           ((not (string-empty-p name))
                                            (append deps-adopted
                                                    (list (make-dependency name
                                                                           version
                                                                           scope
                                                                           optional
                                                                           classifier
                                                                           extension
                                                                           (if (not (string-empty-p exclusions))
                                                                               (list (make-dependency exclusions
                                                                                                      ""
                                                                                                      ""
                                                                                                      ""
                                                                                                      ex-classifier
                                                                                                      ex-extension
                                                                                                      nil)))))))
                                           ; Append another exclusion in case there's no name but exclusions given
                                           ((and (string-empty-p name) (not (string-empty-p exclusions)))
                                            (let* ((last-dep (car (last deps-adopted))))
                                              (puthash 'exclusions
                                                       (append (gethash 'exclusions last-dep nil)
                                                               (list (make-dependency exclusions
                                                                                      ""
                                                                                      ""
                                                                                      ""
                                                                                      ex-classifier
                                                                                      ex-extension
                                                                                      nil)))
                                                       last-dep)
                                              deps-adopted))))))
                                    ; Skipping title line
                                    (cdr deps-table)
                                    :initial-value nil)))
                ; So now I have list of dependencies (as hash maps) which I'm to transform into Clojure's vector of vectors
                ; in Clojure syntax
                (mapconcat #'serialize-dependency deps-adopted "\n"))))))
  #+END_SRC

** render-code-block-if

  Renders a code block if [[#project-specification][the project specification table]] contains a parameter with a given name and a value passing
  an equality condition.

  *Requirements*:
  - A code block with a given name must be defined in file the call is done from.

  *Examples:*
  #+BEGIN_EXAMPLE
    <<render-codeblock-if(name="project-clojurescript-dependencies" if="ClojureScript=yes")>>
    #+CALL: render-codeblock-if(name="project-clojurescript-dependencies" if="ClojureScript=yes")
  #+END_EXAMPLE

  #+CAPTION: *Parameters:*
  #+ATTR_LATEX: :width \textwidth :align |l|l|p{10cm}| :float nil
  | Name      | Default value | Description                                                                        |
  |-----------+---------------+------------------------------------------------------------------------------------|
  | name      | ""            | A code block name to be rendered, the one given in it's ~#+NAME:~ dirrective.      |
  | condition | ""            | Rendering condition given as ~"parameter = value"~, where ~=~ is string comparison |
  |           |               | operation.                                                                         |

  #+NAME: render-codeblock-if
  #+BEGIN_SRC emacs-lisp :var name="" :var condition="" :results value silent
    (save-excursion
      (destructuring-bind (&optional (param-name "") &optional (cond-value "")) (split-string condition "=" t "\s+")
        (let ((param-value (org-babel-execute-src-block
                            nil
                            (cdr (assoc 'get-specification-param org-babel-library-of-babel))
                            (list
                             (cons :var (format "title=\"%s\"" param-name))))))
          (if (string= param-value cond-value)
              (progn
                (org-babel-goto-named-src-block name)
                (let ((tangle-result (org-babel-tangle-single-block "")))
                  (nth 5 tangle-result)))
            ""))))
  #+END_SRC

* Boot-project

  #+SETUPFILE: setup.org
  
** boot.properties

  Файл boot.properties используется Boot для привязки проекта к конкретной версии Boot и запуска этой версии Boot
  на конкретной версии Clojure.

  #+NAME: boot.properties
  #+BEGIN_SRC sh :tangle ../boot.properties :noweb yes
    #http://boot-clj.com
    #<<time-is-now()>>
    BOOT_CLOJURE_NAME=org.clojure/clojure
    BOOT_CLOJURE_VERSION=<<get-specification-param(title="Clojure/Version")>>
    BOOT_VERSION=<<get-specification-param(title="Boot/Version")>>
  #+END_SRC

** build.boot

  Файл ~build.boot~ исполняется Boot при запуске src_sh{boot task}, где ~task~ имя задачи для исполнения. Задачи проекта
  описаны ниже, в соответствующем разделе.

  #+NAME: build.boot
  #+BEGIN_SRC clojure :tangle ../build.boot :noweb yes :exports none
    (require '[clojure.java.io :refer [file]])

    <<set-project-paths>>

    <<render-codeblock-if(name="set-project-clojure-dependency", condition="Clojure=yes")>>

    <<render-codeblock-if(name="set-project-clojurescript-dependency", condition="ClojureScript=yes")>>

    <<set-project-user-dependencies>>

    <<render-codeblock-if(name="boot-clojure-tasks", condition="Clojure=yes")>>

    <<render-codeblock-if(name="boot-clojurescript-tasks", condition="ClojureScript=yes")>>

    <<boot-user-task>>
  #+END_SRC

  Устанавливаем дирректории проекта, если они объявлены в спецификации и присутствуют на диске.

  #+NAME: set-project-paths
  #+BEGIN_SRC clojure
    (def paths [ [:source-paths "<<get-specification-param(title="Clojure/Sources path")>>"]
                 [:source-paths "<<get-specification-param(title="ClojureScript/Sources path")>>"]
                 [:resource-paths "<<get-specification-param(title="Resource path")>>"]
                 [:asset-paths "<<get-specification-param(title="Assets path")>>"] ] )

    (doseq [[ env-key path ] paths]
      (if (and (seq path) (not ((get-env env-key) path)))
        (let [dir (file path)]
          (if (.isDirectory dir)
            (set-env! env-key #(conj % (.getName dir)))))))
  #+END_SRC

  Если в проекте объявлена зависимость от /Clojure/, т.е. в спецификации для параметра ~Clojure~ указано ~yes~,
  то добавляем зависимость от /Clojure/.

  #+NAME: set-project-clojure-dependency
  #+BEGIN_SRC clojure
    (set-env! :dependencies #(conj % '[org.clojure/clojure "<<get-specification-param(title="Clojure/Version")>>"]))
  #+END_SRC

  Если в проекте объявлена зависимость от /ClojureScript/, т.е. в спецификации для параметра ~ClojureScript~
  указано ~yes~, то добавляем зависимость от /ClojureScript/.

  #+NAME: set-project-clojurescript-dependency
  #+BEGIN_SRC clojure
    (set-env! :dependencies #(conj % '[org.clojure/clojurescript "<<get-specification-param(title="ClojureScript/Version")>>"]))
  #+END_SRC

  Добавляем пользовательские зависимости проекта.

  #+NAME: set-project-user-dependencies
  #+BEGIN_SRC clojure
    (let [deps '[
                <<render-project-dependencies()>>
               ]]
      (set-env! :dependencies #(into % deps)))
  #+END_SRC

*** Boot-задачи проекта для /Clojure/

   Boot-задачи для /Clojure/ будут добавлены в результирующий ~build.boot~, если в спецификации проекта в параметре
   ~Clojure~ указано значение ~yes~.

   Все блоки кода с boot-задачами для /Clojure/ должны иметь имя ~boot-clojure-task~. Каждая задача с таким именем будет
   включена в результирующий ~build.boot~.

   #+NAME: boot-clojure-tasks
   #+BEGIN_SRC clojure :noweb yes :exports none
     <<boot-clojure-task>>
   #+END_SRC

**** clj-build
    :PROPERTIES:
    :CUSTOM_ID: clj-build
    :END:

    Эта задача строит uberjar проекта который запускается командой.

    #+BEGIN_SRC sh :dir ".." :noweb yes
      java -jar <<get-specification-param(title="Target path")>>/project.jar
    #+END_SRC

    #+NAME: boot-clojure-task
    #+BEGIN_SRC clojure
      (deftask clj-build
        "Builds project's uberjar"
        []
        (comp (pom :project '<<get-specification-param(title="Project name")>>
                   :version "<<get-specification-param(title="Project version")>>")
              (aot :all true)
              (uber)
              (jar :main '<<get-specification-param(title="Project name", splitby="/", joinby=".")>>.<<get-specification-param(title="Main namespace")>>)
              (target :dir #{"<<get-specification-param(title="Target path")>>"})))
    #+END_SRC

    Для вызова задачи выполните: src_sh[:dir ".."]{boot clj-build}

**** clj-run

    Эта задача запускает проект в той же Java-среде в которой запущен Boot. Перед запуском надо скомпелировать проект
    задачей [[#clj-build][clj-build]].

    #+NAME: boot-clojure-task
    #+BEGIN_SRC clojure
      (deftask clj-run
        "Runs the project's main function"
        []
        (require '<<get-specification-param(title="Project name", splitby="/", joinby=".")>>.<<get-specification-param(title="Main namespace")>>)
        (let [main-fn (resolve '<<get-specification-param(title="Project name", splitby="/", joinby=".")>>.<<get-specification-param(title="Main namespace")>>/-main)]
          (comp (aot :all true) (with-pass-thru _ (main-fn)))))
    #+END_SRC

    Для вызова задачи выполните: src_sh[:dir ".."]{boot clj-run}

*** Boot-задачи проекта для /ClojureScript/

   Boot-задачи для /ClojureScript/ будут добавлены в результирующий ~build.boot~, если в спецификации проекта
   в параметре ~ClojureScript~ указано значение ~yes~.

   Все блоки кода с boot-задачами для /ClojureScript/ должны иметь имя ~boot-clojurescript-task~. Каждая задача с таким
   именем будет включена в результирующий ~build.boot~.

   #+NAME: boot-clojurescript-tasks
   #+BEGIN_SRC clojure :noweb yes :exports none
     <<boot-clojurescript-task>>
   #+END_SRC

**** cljs-figwheel

    Эта задача интерфейс к *figwheel*, для запуска используйте src_sh[:dir "."]{boot cljs-figwheel}.\\

    Компилирует ClojureScript файлы, запускает HTTP-server обслуживающий дирректорию публичных ресурсов,
    запускает монитор для перекомпиляции, запускает nRepl сервер. Для входа в ClojureScript REPL выполнить
    "9 шагов к успеху":

    1. выполнить src_sh{boot cljs-figwheel}
    2. дождаться звукового сигнала
    3. посмотреть в консоли адрес и порт запущенного веб-сервера (обычно http://localhost:3449)
    4. открыть браузер, открыть URL, увидеть в JavaScript-консоли сообщение Opened Websocket REPL connection
    5. посмотреть в консоли адрес и порт nRepl сервера, передать их в следующем шаге
    6. выполнить src_emacs-lisp{(cider-connect HOST PORT)} или M-x cider-connect и ввести HOST и PORT, хотя, походу
       cider сам прекрасно всё цепляет из файла ~.nrepl-port~, так что можно просто два раза ENTER нажать
    7. в REPL буфере ввести src_clojure{(cljs-repl)} чтобы запустить ClojureScript REPL
    8. в REPL буфере ввести src_clojure{(.log js/console "OK!")}
    9. увидеть сообщение "OK!" в JavaScript-консоли браузера

    #+NAME: boot-clojurescript-task
    #+BEGIN_SRC clojure
      (set-env! :dependencies #(into % '[[ajchemist/boot-figwheel "0.5.4-6" :scope "test"]
                                         [org.clojure/tools.nrepl "0.2.12" :scope "test"]
                                         [com.cemerick/piggieback "0.2.1" :scope "test"]
                                         [figwheel-sidecar "0.5.7" :scope "test"]]))

      (require '[boot-figwheel :refer [figwheel start-figwheel! stop-figwheel! start-autobuild stop-autobuild cljs-repl fig-status]])

      ;; This is for (cider-connect) to work.
      ;; NOTE: do not use (cider-jack-in), use (cider-connect) instead
      ;; ---------------------------
      ;; Start of cider related code
      (swap! boot.repl/*default-dependencies* concat '[[cider/cider-nrepl "<<get-specification-param(title="Cider/Version")>>"]])
      (swap! boot.repl/*default-middleware* conj 'cider.nrepl/cider-middleware)
      ;; End of cider related code

      (deftask cljs-figwheel
        "Compiles ClojureScript, serves it, autobuilds"
        []
        (comp
         (figwheel :build-ids ["dev"]
                   ;:once-build ["advanced"]
                   :all-builds [{:id "dev"
                                 :source-paths (seq (get-env :source-paths))
                                 :compiler {:main '<<get-specification-param(title="Project name", splitby="/", joinby=".")>>.<<get-specification-param(title="Main namespace")>>
                                            :optimizations :none
                                            :source-map true
                                            :output-to "app.js"}
                                 :figwheel {:build-id "dev"
                                            :on-jsload '<<get-specification-param(title="Project name", splitby="/", joinby=".")>>.<<get-specification-param(title="Main namespace")>>/-main
                                            :heads-up-display true
                                            :autoload true
                                            :debug false}}]
                   :figwheel-options {:http-server-root "public"
                                      :open-file-command "emacsclient"
                                      :repl false}
                   :target-path "<<get-specification-param(title="Public resources path")>>")
         (speak)
         (repl)))
    #+END_SRC

*** Пользовательские boot-задачи

   Все блоки кода с пользовательскими boot-задачами должны иметь имя ~boot-user-task~. Каждая задача с таким
   именем будет включена в результирующий ~build.boot~.

* Project code

  #+SETUPFILE: ../build/setup.org
  
** Пространство имён Core

*** Функции

**** -main

    #+NAME: core/main.clj
    #+BEGIN_SRC clojure :tangle (org-sbe in-clj-path (path \"core.clj\"))
      (ns <<get-specification-param(title="Project name", splitby="/", joinby=".")>>.<<get-specification-param(title="Main namespace")>>
        (:gen-class))

      (defn -main
        "Project's entry point"
        [& args]
        (println "Hello, from <<get-specification-param(title="Project name")>>!"))
    #+END_SRC

    #+NAME: core/main.cljs
    #+BEGIN_SRC clojure :tangle (org-sbe in-cljs-path (path \"core.cljs\"))
      (ns <<get-specification-param(title="Project name", splitby="/", joinby=".")>>.<<get-specification-param(title="Main namespace")>>
        (:refer-clojure))

      (enable-console-print!)

      (defn ^:export -main
        "Project's entry point"
        [& args]
        (println "Hello, from <<get-specification-param(title="Project name")>>!!"))
    #+END_SRC

    #+NAME: index.html
    #+BEGIN_SRC html :tangle (org-sbe in-resources-path (path \"public/index.html\"))
      <!doctype html>
      <html>
       <head>
        <title><<get-specification-param(title="Project name")>></title>
       </head>
       <body>
         <script src="app.js"></script>
       </body>
     </html>
  #+END_SRC

* Footnotes

[fn:1] For the one interested please see the documentation for ~cemeric.pomegranate.aether/resolve-dependencies~ function
